# aspz-lab8
ТВ-31 Троцюк Андрій

Варіант 17

Завдання 8.1

Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

Результат:
Так, write(fd, buffer, nbytes) може повернути значення менше за nbytes, якщо запис неможливо виконати повністю , наприклад, у неблокуючому режимі або коли буфер заповнений. У моїй програмі при записі 1 МБ у неблокуючий pipe було записано лише 65536 байт, що демонструє частковий запис.

Завдання 8.2

 Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
lseek(fd, 3, SEEK_SET);
read(fd, &buffer, 4);
де виклик lseek переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

Результат:
У файлі з байтами 4, 5, 2, 2, 3, 3, 7, 9, 1, 5 я виконав lseek(fd, 3, SEEK_SET), щоб перемістити покажчик на 4-й байт (індекс 3), після чого read(fd, &buffer, 4) зчитав 4 байти. У результаті буфер містив значення 2, 3, 3, 7, оскільки читання почалося з 3-ї позиції (нумерація з нуля) і охопило байти з індексами 3, 4, 5 та 6. Це очікувана поведінка, адже lseek() змінює поточну позицію у файлі, з якої система починає читання.

Завдання 8.3

Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.
Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.

Результат:
Я реалізував програму, яка автоматично генерує масиви різних типів (відсортовані, зворотно відсортовані, однакові та випадкові), сортує їх за допомогою qsort, вимірює час виконання та перевіряє правильність сортування. За результатами тестів найповільніше працював qsort на випадковому масиві.


Завдання 8.4

 Виконайте наступну програму на мові програмування С:
int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
}
Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?

Результат:
Після запуску програми я отримав два рядки: 1212 і 0. Це означає, що fork() створив новий процес. У батьківському процесі fork() повернув PID нащадка (в моєму випадку  1212), а в нащадковому  0. Обидва процеси вивели своє значення, і тому бачимо два рядки. Порядок виводу залежить від того, який процес першим потрапив на виконання.

Завдання 8.17(індивідуальне)

Продемонструйте ситуацію, в якій fork() і exec() можуть порушити логіку програми через неправильне управління дескрипторами.

Результат:

Я створив програму, де відкрив файл до виклику fork(), а в дочірньому процесі виконав exec() без закриття дескриптора. Після запуску програми ввід з клавіатури дублювався, кожна літера виводилась двічі , що стало наслідком того, що cat, виконаний у дочірньому процесі, успадкував стандартні дескриптори вводу/виводу. Це порушило очікувану поведінку програми і показує, чому важливо закривати або перенаправляти дескриптори перед exec().

